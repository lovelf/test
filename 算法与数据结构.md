### 算法与数据结构
- [浅谈算法和数据结构: 一 栈和队列](http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html)
  - 栈(stack) 后进先出
  
   方法 | 说明
   --- | ---
   Stack<T>() | 创建一个空的栈
   void Push(T s) | 往栈中添加一个新的元素
   T Pop() | 删除并返回最近添加的元素
   boolean IsEmpty() | 栈是否为空
   int Size() | 栈中元素的个数

  - 队列(queue) 先进先出
  
- [浅谈算法和数据结构: 五 优先级队列与堆排序](http://www.cnblogs.com/yangecnu/p/Introduce-Priority-Queue-And-Heap-Sort.html)
  - 二叉堆排序
  > 二叉堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 有了这一性质，那么二叉堆上最大值就是根节点了。
  
```.net
private static void Swim(int k)
{
     // 如果元素比其父元素大，则交换
     while(k > 1 && pq[k].CompareTo(pq[k/2])>0)
     {
         Swap(pq, k, k/2);
         k = k / 2;  
     }
}

// 插入数据
public static void Insert(T s)
{
   // 将元素添加到数组末尾
   pq[++N] = s;
   Swim(N);
}

private static void Sink(int k)
{
    while(2*k < N) 
    {
        int j = 2*k;
        // 去左右子节点，稍大的那个元素作比较
        if (pq[j].CompareTo[pq[j+1])> 0) j++;
        
        // 如果父节点比这个较大的子元素还大，表示满足要求，退出
        if （pq[k].CompareTo(pq[j])>0) break;
        // 否则，与子节点进行交换
        Swap(pq, k, j);
        k = j;
    }
}


public static T DelMax()
{
   // 根元素从1开始，0不存放值
   T max = pq[1];
   // 将最后一个元素和根元素进行交换
   Swap(pq, 1, N--);
   // 对根元素节点从上至下重新建堆
   Sink(1);
   // 将最后一个元素设置为空
   pg[N+1] = default(T);
   return max;
}

// 创建最大二叉堆
for (int k = N/2; k >= 1; k--)
{
   Sink(k);
}

while (N > 1)
{
  Swap(pq, 1, N--);
  Sink(pq, 1, N);
}
```

- [浅谈算法和数据结构: 二 基本排序算法](http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html)
  - 选择排序
  
  > 选择排序很简单，他的步骤如下：1.从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。2.从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。3.以此类推，直到所有元素均排序完毕
  ```.net
  public static void SelectionSor(T[] array)
  {
      int n = array.Length;
      
      for (int i = 0; i < n; i++)
      {
          int min = i;
          // 从第i+1个元素开始，找最小值
          for (int j = i + 1; j < n; j++)
          {
               if (array[min].CompareTo(array[j]) > 0)
                   min = j;
          }
          // 找到之后和第i个元素交换
          Swap(array, i, min);
      }
  }
  ```
  
  - 插入排序
  >从第一个元素开始，该元素可以认为已经被排序
   取出下一个元素，在已经排序的元素序列中从后向前扫描
   如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止；
   如果该元素大于前面的元素（已排序），则重复步骤2
   重复步骤2~4 直到所有元素都排好序 。

```.net
public static void InsertionSort(T[] array)
{
   int n = array.Length;
   // 从第二个元素开始
   for (int i = 1; i < n; i++)
   {  
       // 从第i个元素开始，一次和前面已经排好的i-1个元素比较，如果小于，则交换
       for (int j = i; j > 0; j--)
       {
           if (array[j].CompareTo(array[j-1]) < 0)
           {
               Swap(array, j, j - 1);
           }
           else break;
        }
}
```

- 希尔排序 
  - [另解](http://blog.csdn.net/morewindows/article/details/6668714)

```.net
public static void ShellSort(T[] array)
{
    int n = array.Length;
    int h = 1;
    while (h < n /3) h = h*3 + 1;
    while (h >= 1)
    {
       // 从第二个元素开始
       for （int i = 1； i < n; i++)
       {
           for (int j = 1; j > =h; j = j-h) {
                if (array[j].CompareTo[array[j-h]) < 0)
                {
                    Swap(array, j, j-h);
                }
                else // 如果大于，则不用继续往前比较了，因为前面的元素已经排好序
                    break;
           }
        }
        // 步长除3递减
        h = h / 3;
    }
}
```

- [浅谈算法和数据结构: 三 合并排序](http://www.cnblogs.com/yangecnu/p/Introduce-Merge-Sort.html)

```.net
private static void Merge(T[] array, int lo, int mid, int hi)
{
    int i = lo, j = mid +1;
    // 把元素拷贝到辅助数组中
    for (int k = lo; k < hi; k++)
    {
        aux[k] = array[k];
    }
    // 然后按照规则将数据从辅助数组中拷贝回原始的array中
    for (int k = lo; k < = hi; k++)
    {
        // 如果左边元素没了，直接将右边的元素合并到原数组中
        if (i > mid)
        {
            array[k] = aux[j++];
        } // 如果右边元素没有了，直接将左边的剩余元素合并到原数组中
        else if (j > hi)
        {
            array[k] = aux[i++];
        } // 如果左边比右边小，则将左边的元素拷贝到原数组中
        else if （aux[i].CompareTo(aux[j]) < 0 )
        {
            array[k] = aux[i++];
        }
        else
        {
            array[k] = aux[j++];
        }
    }
}

public static void Sort(T[] array)
{
    aux = new T[array.Length];
    Sort(array, 0, array.Length - 1);
}

private static void Sort(T[] array, int lo, int hi)
{
   if (lo >= hi) return; // 如果下标大于上标，则返回
   int mid = lo + （hi -lo)/2; // 平分数组
   Sort(array, lo, mid); //循环对左侧元素排序
   Sort(array, mid + 1, hi); // 循环对右侧元素排序
   Merge(array, lo, mid, hi); // 对左右排好的序列进行合并
}
```

- [浅谈算法和数据结构: 四 快速排序](http://www.cnblogs.com/yangecnu/p/Introduce-Quick-Sort.html)
```net
// 核心算法Partion
private static int Partition(T[] array, int lo, int hi)
{
    int i = lo, j = hi + 1;
    while(true)
    {
        // 从左至右扫描，如果碰到比基准元素array[lo]小，则该元素已经位于正确的分区，i自增，继续比较i+1;
        // 否则，退出循环，准备交换
        while (array[++i].CompareTo(array[lo]) < 0)
        {
            // 如果扫描到了最右端，退出循环
            if (i == hi) break;
        }

        //从右自左扫描，如果碰到比基准元素array[lo]大，则该元素已经位于正确的分区，j自减，继续比较j-1
        // 否则， 退出循环，准备交换
        while (array[--j].CompareTo(array[lo]) > 0)
        {
            // 如果扫描到了最左端，退出循环
            if (j == lo) break;
        }
        
        // 如果相遇，退出循环
        if (i >= j) break;
        
        // 交换a[i],a[j]右两个元素，交换完后他们都位于正确的分区
        Swap(array, i, j);
    }
    //经过相遇后，最后一次a[i]和a[j]的交换
    //a[j]比a[lo]小，a[i]比a[lo]大，所以将基准元素与a[j]交换
    Swap(array, lo, j);
    // 返回扫描相遇的位置点
    return j;
}

public static void Sort(T[] array)
{
    Sort(array, 0, array.Length - 1);
}

prviate static void Sort(T[] array, int lo, int hi)
{
   // 如果子序列为1，则直接返回
   if (lo >= hi) return;
   // 划分，划分完成之后，分为左右序列，左边所有元素小于array[index], 右边所有元素大于array[index]
   int index = Partition(array, lo, hi);
   
   //对左右子序列进行排序完成之后，整个序列就有序了
        //对左边序列进行递归排序
   Sort(array, lo, index-1);
   // 对右边序列进行递归排序
   Sort(array, index + 1, hi);
}
```

- [](http://www.cnblogs.com/yangecnu/p/Introduce-Symbol-Table-and-Elementary-Implementations.html)
- [浅谈算法和数据结构: 七 二叉查找树](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)
  - 定义
    - 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：
    - 1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
    - 3. 任意节点的左、右子树也分别为二叉查找树。
    - 4. 没有键值相等的节点（no duplicate nodes）。
  - 实现
  ```net
  private Node root;
  private class Node
  {
      public Node Left;
      public Node Right;
      public int Number;
      public Tkey key;
      public TValue value;

      public Node(Tkey key, Tvalue value, int number)
      {
          this.Key = key;
          this.Value = value;
          this.Number = number;
      }
  }

  public override TValue Get(TKey key)
  {
     TValue result = default(TValue);
     Node node = root;
     while (node != null)
     {
         if (key.CompareTo(node.Key)>0)
         {
            node = node.Right;
         }
         else if (key.compareTo(node.Key) < 0)
         {
            node = node.Left;
         }
         else
         {
            result = node.Value;
            break;
         }
     }
     return result;
  }

  // 迭代
  public Tvalue Get(TKey key)
  {
      return GetValue(root, key);
  }

  public TValue GetValue(Node root, TKey key)
  {
      if (root == null) return default(TValue);
      int cmp = key.CompareTo(root.key);
      if (cmp > 0) GetValue(root.Right, key);
      else if (cmp < 0) return GetValue(root.Left, key);
      else return root.Value);
  }

  public override void Put(TKey key, TValue value)
  {
      root = Put(root, key, value);
  }

  private Node Put(Node x, TKey key, TValue value)
  {
      // 如果节点为空，则创建新的节点，并返回
      // 否则比较大小判断是左节点还是右节点，然后继续查找左子树还是右子树
      // 同时更新节点的Number值
      if (x == null) return new Node(key, value,1);
      int cmp = key.CompareTo(x.Key);
      if (cmp < 0) x.Left = Put(x.Left, key, value);
      else if (cmp > 0) x.Right = Put(x.Right, key, value);
      else x.Value = value;
      x.Number = Size(x.Left) + Size(x.Right) + 1;
      return x;
  }

  private int Size(Node node)
  {
     if (node == null) return 0;
     else return node.Number;
  }

  public override TKey GetMax()
  {
      TKey maxItem = default(TKey);
      Node s = root;
      while (s.Right != null)
      {
         s = s.Right;
      }
      maxItem = s.Key;
      return maxItem;
  }

  public override Tkey GetMin()
  {
       TKey minItem = default(TKey);
       Node s = root;
       while (s.Left != null)
       {
            s = s.Left;
        }
        minItem = s.Key;
        return minItem;
   }

   public Tkey Floor(TKey key)
   {
       Node x = Floor(root, key);
       if (x ! = null) return x.Key;
       else return default(Tkey);
   }

   private Node Floor(Node x, Tkey key)
   {
       if (x == null) return null;
       int cmp = key.CompareTo(x.Key);
       if (cmp < 0) return Floor(x.Left, key);
       else
       {
          Node right = Floor(x.Right, key);
          if (right == null) return x;
          else return right;  
       }
   }

   public void DelMin()
   {
      root = DelMin(root);
   }

   private Node DelMin(Node root）
   {
       if (root.Left == null) return root.Right;
       root.Left = DelMin(root.Left);
       root.Number = Size(root.Left) + Size(root.Right) + 1;
       return root;
    }

    public void Delete(Tkey key)
    {
       root = Delete(root, key);
    }

    private Node Delete(Node x, Tkey key)
    {
        int cmp = key.CompareTo(x.Key);
        if (cmp > 0) x.Right = Delete(x.Right, key);
        else if (cmp < 0) x.Left = Delete(x.Left, key);
        else
        {
            if (x.Left == null) return x.Right;
            else if (x.Right == null) return x.Left;
            else
            {
               Node t = x;
               x = GetMinNode(t.Right);
               x.Right = DelMin(t.right);
               x.Left = to.Left;
            }
        }
        x.Number = Size(x.Left) + Size(x.Right) +1;
        return x;
    }

    private Node GetMinNode(Node x)
    {
       if (x.Left == null) return x;
       else return GetMinNode(x.Left);
    }
  ```

- [浅谈算法和数据结构: 八 平衡查找树之2-3树](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)

- [浅谈算法和数据结构: 九 平衡查找树之红黑树](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)
  - 表示
  ```net
  private Node RotateLeft(Node h)
  {
      Node x = h.Right;
      // 将x的左节点复制给h右节点
      h.right = x.left;
      // 将h复制给x右节点
      x.Left = h;
      x.Color = h.Color;
      h.Color = RED;
      return x;
  }

  private Node RotateRight(Node h)
  {
      Node x = h.Left;
      h.Left = x.Right;
      
      x.Right = h;
      x.Color = h.Color;
      h.Color = REd;
      return x;
  }

  //  插入
  public override void Put(TKey key, TValue value)
  {
      root = Put(root, key, value);
      root.Clor = BLACK;
  }

  private Node Put(Node h, TKey key, TValue value)
  {
      if (h == null) return new Node(key, value, 1, RED);
      int cmp = key.CompareTo(h.Key);
      if (cmp < 0) h.Left = Put(h.Left, key, value);
      else if (cmp > 0) h.Right = Put(h.Right, key, value);
      else h.Value = value;

      // 平衡化操作
      if (IsRed(h.Right) && !IsRed(h.Left)) h.RotateLeft(h);
      if (IsRed(h.Right) && IsRed(h.Left.Left)) h = RotateRight(h);
      if (IsRed(h.Left) && IsRed(h.Right)) h = FlipColor(h);

      h.number = Size(h.Left) + Size(h.Right) +1;
      return h;
  }

  ```

- [浅谈算法和数据结构: 十 平衡查找树之B树](http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html)
  - [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

- [浅谈算法和数据结构（12）：无向图相关算法基础](http://blog.jobbole.com/79314/)
  
 