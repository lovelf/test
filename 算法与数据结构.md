### 算法与数据结构
- [浅谈算法和数据结构: 一 栈和队列](http://www.cnblogs.com/yangecnu/p/Introduction-Stack-and-Queue.html)
  - 栈(stack) 后进先出
  
   方法 | 说明
   --- | ---
   Stack<T>() | 创建一个空的栈
   void Push(T s) | 往栈中添加一个新的元素
   T Pop() | 删除并返回最近添加的元素
   boolean IsEmpty() | 栈是否为空
   int Size() | 栈中元素的个数

  - 队列(queue) 先进先出
  
- [浅谈算法和数据结构: 五 优先级队列与堆排序](http://www.cnblogs.com/yangecnu/p/Introduce-Priority-Queue-And-Heap-Sort.html)
  - 二叉堆排序
  > 二叉堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 有了这一性质，那么二叉堆上最大值就是根节点了。
  
```.net
private static void Swim(int k)
{
     // 如果元素比其父元素大，则交换
     while(k > 1 && pq[k].CompareTo(pq[k/2])>0)
     {
         Swap(pq, k, k/2);
         k = k / 2;  
     }
}

// 插入数据
public static void Insert(T s)
{
   // 将元素添加到数组末尾
   pq[++N] = s;
   Swim(N);
}

private static void Sink(int k)
{
    while(2*k < N) 
    {
        int j = 2*k;
        // 去左右子节点，稍大的那个元素作比较
        if (pq[j].CompareTo[pq[j+1])> 0) j++;
        
        // 如果父节点比这个较大的子元素还大，表示满足要求，退出
        if （pq[k].CompareTo(pq[j])>0) break;
        // 否则，与子节点进行交换
        Swap(pq, k, j);
        k = j;
    }
}


public static T DelMax()
{
   // 根元素从1开始，0不存放值
   T max = pq[1];
   // 将最后一个元素和根元素进行交换
   Swap(pq, 1, N--);
   // 对根元素节点从上至下重新建堆
   Sink(1);
   // 将最后一个元素设置为空
   pg[N+1] = default(T);
   return max;
}

// 创建最大二叉堆
for (int k = N/2; k >= 1; k--)
{
   Sink(k);
}

while (N > 1)
{
  Swap(pq, 1, N--);
  Sink(pq, 1, N);
}
```

- [浅谈算法和数据结构: 二 基本排序算法](http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html)
  - 选择排序
  
  > 选择排序很简单，他的步骤如下：1.从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。2.从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。3.以此类推，直到所有元素均排序完毕
  ```.net
  public static void SelectionSor(T[] array)
  {
      int n = array.Length;
      
      for (int i = 0; i < n; i++)
      {
          int min = i;
          // 从第i+1个元素开始，找最小值
          for (int j = i + 1; j < n; j++)
          {
               if (array[min].CompareTo(array[j]) > 0)
                   min = j;
          }
          // 找到之后和第i个元素交换
          Swap(array, i, min);
      }
  }
  ```
  
  - 插入排序
  >从第一个元素开始，该元素可以认为已经被排序
   取出下一个元素，在已经排序的元素序列中从后向前扫描
   如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止；
   如果该元素大于前面的元素（已排序），则重复步骤2
   重复步骤2~4 直到所有元素都排好序 。

```.net
public static void InsertionSort(T[] array)
{
   int n = array.Length;
   // 从第二个元素开始
   for (int i = 1; i < n; i++)
   {  
       // 从第i个元素开始，一次和前面已经排好的i-1个元素比较，如果小于，则交换
       for (int j = i; j > 0; j--)
       {
           if (array[j].CompareTo(array[j-1]) < 0)
           {
               Swap(array, j, j - 1);
           }
           else break;
        }
}
```

- 希尔排序 
  - [另解](http://blog.csdn.net/morewindows/article/details/6668714)

```.net
public static void ShellSort(T[] array)
{
    int n = array.Length;
    int h = 1;
    while (h < n /3) h = h*3 + 1;
    while (h >= 1)
    {
       // 从第二个元素开始
       for （int i = 1； i < n; i++)
       {
           for (int j = 1; j > =h; j = j-h) {
                if (array[j].CompareTo[array[j-h]) < 0)
                {
                    Swap(array, j, j-h);
                }
                else // 如果大于，则不用继续往前比较了，因为前面的元素已经排好序
                    break;
           }
        }
        // 步长除3递减
        h = h / 3;
    }
}
```